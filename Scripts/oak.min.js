var Parameter;
(function (Parameter) {
    Parameter[Parameter["immediate"] = 0] = "immediate";
    Parameter[Parameter["register"] = 1] = "register";
    Parameter[Parameter["condition"] = 2] = "condition";
    Parameter[Parameter["offset"] = 3] = "offset";
    Parameter[Parameter["special"] = 4] = "special";
})(Parameter || (Parameter = {}));
;
var BitRange = (function () {
    function BitRange(field, start, bits, parameter, constant, limitlessBits) {
        if (parameter === void 0) { parameter = null; }
        if (constant === void 0) { constant = null; }
        if (limitlessBits === void 0) { limitlessBits = null; }
        this.field = field;
        this.start = start;
        this.bits = bits;
        this.parameter = parameter;
        this.constant = constant;
        this.limitlessBits = limitlessBits;
    }
    return BitRange;
}());
;
var Format = (function () {
    function Format(name, ranges, parameters, parameterTypes, regex, disassembly, rData1Arg, rData2Arg, processSpecialParameter, decodeSpecialParameter) {
        if (rData1Arg === void 0) { rData1Arg = 1; }
        if (rData2Arg === void 0) { rData2Arg = 2; }
        if (processSpecialParameter === void 0) { processSpecialParameter = null; }
        if (decodeSpecialParameter === void 0) { decodeSpecialParameter = null; }
        this.name = name;
        this.parameters = parameters;
        this.ranges = ranges;
        this.parameterTypes = parameterTypes;
        this.regex = regex;
        this.disassembly = disassembly;
        this.processSpecialParameter = processSpecialParameter;
        this.decodeSpecialParameter = decodeSpecialParameter;
        this.rData1Arg = rData1Arg;
        this.rData2Arg = rData2Arg;
    }
    Format.prototype.disassemble = function (mnemonic, args, abiNames) {
        var output = this.disassembly;
        output = output.replace("@mnem", mnemonic);
        for (var i = 0; i < this.parameters.length; i++) {
            if ((args[i] == null) || (output.search("@arg") === -1)) {
                console.log("Disassembler note: Argument mismatch.");
                break;
            }
            output = output.replace("@arg", (this.parameterTypes[i] === Parameter.register) ? abiNames[args[i]] : args[i].toString());
        }
        return output;
    };
    Format.prototype.parameterBitRangeIndex = function (parameter) {
        for (var i = 0; i < this.ranges.length; i++) {
            if (this.ranges[i].field === parameter) {
                return i;
            }
            var limits = /([A-za-z]+)\s*\[\s*(\d+)\s*:\s*(\d+)\s*\]/.exec(this.ranges[i].field);
            if (limits !== null) {
                if (limits[1] === parameter) {
                    return i;
                }
            }
        }
        return null;
    };
    Format.prototype.fieldParameterIndex = function (range) {
        for (var i = 0; i < this.parameters.length; i++) {
            if (this.parameters[i] == range) {
                return i;
            }
        }
        return null;
    };
    return Format;
}());
;
var Instruction = (function () {
    function Instruction(mnemonic, format, constants, constValues, executor, memory, wb, signed, available) {
        if (signed === void 0) { signed = true; }
        if (available === void 0) { available = true; }
        this.mnemonic = mnemonic;
        this.format = format;
        this.constants = constants;
        this.constValues = constValues;
        this.available = available;
        this.signed = signed;
        this.executor = executor;
        this.writeBack = wb;
        this.memory = memory;
    }
    Instruction.prototype.pad = function (str, length) {
        var padded = str;
        for (var i = 0; i < length - str.length; i++) {
            padded = "0" + padded;
        }
        return padded;
    };
    Instruction.prototype.mask = function () {
        var str = "";
        for (var i = 0; i < this.format.ranges.length; i++) {
            var index = this.constants.indexOf(this.format.ranges[i].field);
            if (index !== -1) {
                str += this.pad(this.constValues[index].toString(2), this.format.ranges[i].bits);
            }
            else if (this.format.ranges[i].constant != null) {
                str += this.pad(this.format.ranges[i].constant.toString(2), this.format.ranges[i].bits);
            }
            else {
                for (var j = 0; j < this.format.ranges[i].bits; j++) {
                    str += "X";
                }
            }
        }
        return str;
    };
    ;
    Instruction.prototype.match = function (machineCode) {
        var machineCodeMutable = machineCode >>> 0;
        var maskBits = this.mask().split("");
        for (var i = 31; i >= 0; i--) {
            if (maskBits[i] === "X") {
                machineCodeMutable = machineCodeMutable >>> 1;
                continue;
            }
            if (parseInt(maskBits[i]) !== (machineCodeMutable & 1)) {
                return false;
            }
            machineCodeMutable = machineCodeMutable >>> 1;
        }
        //console.log("Match Log: Matched 0b" + (machineCode >>> 0).toString(2) + " with " + this.mnemonic + ".");
        return true;
    };
    Instruction.prototype.template = function () {
        return parseInt(this.mask().split("X").join("0"), 2);
    };
    ;
    return Instruction;
}());
;
var InstructionSet = (function () {
    /*
        InstructionSet initializer
    */
    function InstructionSet(name, bits, formats, instructions, dataDirectives, dataDirectiveSizes, abiNames, process, tokenize, assemble) {
        this.name = name;
        this.bits = bits;
        this.formats = formats;
        this.instructions = instructions;
        this.dataDirectives = dataDirectives;
        this.dataDirectiveSizes = dataDirectiveSizes;
        this.abiNames = abiNames;
        this.processParameter = process;
        this.tokenize = tokenize;
        this.assemble = assemble;
    }
    //Return Mnemonic Index (True)
    InstructionSet.prototype.mnemonicSearch = function (mnemonic) {
        for (var i = 0; i < this.instructions.length; i++) {
            if (this.instructions[i].mnemonic == mnemonic) {
                return i;
            }
        }
        return -1;
    }; //Worst case = instructions.length
    return InstructionSet;
}());
;
/// <reference path="InstructionSet.ts"/>
/// <reference path="Utils.ts" />
//The MIPS Instruction Set Architecture
function Oak_gen_MIPS() {
    //Formats and Instructions
    var formats = [];
    var instructions = [];
    //R-Type
    formats.push(new Format("R", [
        new BitRange("opcode", 26, 6),
        new BitRange("rs", 21, 5, 1),
        new BitRange("rt", 16, 5, 2),
        new BitRange("rd", 11, 5, 0),
        new BitRange("shamt", 6, 5, null, 0),
        new BitRange("funct", 0, 6)
    ], ["rd", "rt", "rs"], [Parameter.register, Parameter.register, Parameter.register], /[a-zA-Z]+\s*(\$[A-Za-z0-9]+)\s*,\s*(\$[A-Za-z0-9]+)\s*,\s*(\$[A-Za-z0-9]+)/, "@mnem @arg, @arg, @arg"));
    var rType = formats[formats.length - 1];
    instructions.push(new Instruction("ADD", rType, ["opcode", "funct"], [0x0, 0x20], function (core) {
        core.rd = core.rfBubble.arguments[0];
        return core.rfBubble.rsData + core.rfBubble.rtData;
    }, function (core) {
        return null;
    }, function (core) {
        core.registerFile.write(core.tcBubble.arguments[0], core.tcBubble.aluOut);
        return 0;
    }));
    instructions.push(new Instruction("XOR", rType, ["opcode", "funct"], [0x0, 0x26], function (core) {
        core.rd = core.rfBubble.arguments[0];
        return core.rfBubble.rsData ^ core.rfBubble.rtData;
    }, function (core) {
        return null;
    }, function (core) {
        core.registerFile.write(core.tcBubble.arguments[0], core.tcBubble.aluOut);
        return 0;
    }));
    instructions.push(new Instruction("SLT", rType, ["opcode", "funct"], [0x0, 0x2A], function (core) {
        core.rd = core.rfBubble.arguments[0];
        return (core.rfBubble.rsData < core.rfBubble.rtData) ? 1 : 0;
    }, function (core) {
        return null;
    }, function (core) {
        core.registerFile.write(core.tcBubble.arguments[0], core.tcBubble.aluOut);
        return 0;
    }));
    //R-Jump Subtype
    formats.push(new Format("RJ", [
        new BitRange("opcode", 26, 6),
        new BitRange("rs", 21, 5, 0),
        new BitRange("rt", 16, 5, null, 0),
        new BitRange("rd", 11, 5, null, 0),
        new BitRange("shamt", 6, 5, null, 0),
        new BitRange("funct", 0, 6)
    ], ["rs"], [Parameter.register], /[a-zA-Z]+\s*(\$[A-Za-z0-9]+)/, "@mnem @arg"));
    var rjSubtype = formats[formats.length - 1];
    instructions.push(new Instruction("JR", rjSubtype, ["opcode", "funct"], [0x0, 0x08], function (core) {
        return null; //Should be handled earlier 
    }, function (core) {
        core.rd = 31;
        return null;
    }, function (core) {
        return null;
    }));
    //R-Constant Subtype
    formats.push(new Format("RC", [
        new BitRange("funct", 0, 32)
    ], [], [], /[a-zA-Z]+/, "@mnem"));
    var rcSubtype = formats[formats.length - 1];
    instructions.push(new Instruction("SYSCALL", rcSubtype, ["funct"], [0xC], function (core) {
        this.rd = null;
        return null;
    }, function (core) {
        return null;
    }, function (core) {
        core.ecall();
        throw "SYSCALL";
    }));
    instructions.push(new Instruction("NOP", rcSubtype, ["funct"], [0], function (core) {
        this.rd = null;
        return null;
    }, function (core) {
        return null;
    }, function (core) {
        return null;
    }));
    //I-Type
    formats.push(new Format("I", [
        new BitRange("opcode", 26, 6),
        new BitRange("rs", 21, 5, 1),
        new BitRange("rt", 16, 5, 0),
        new BitRange("imm", 0, 16, 2)
    ], ["rt", "rs", "imm"], [Parameter.register, Parameter.register, Parameter.immediate], /[a-zA-Z]+\s*(\$[A-Za-z0-9]+)\s*,\s*(\$[A-Za-z0-9]+)\s*,\s*(-?[a-zA-Z0-9_]+)/, "@mnem @arg, @arg, @arg"));
    var iType = formats[formats.length - 1];
    //I-type instructions
    instructions.push(new Instruction("ADDI", iType, ["opcode"], [0x8], function (core) {
        core.rd = core.rfBubble.arguments[0];
        console.log("EX ADDI ", core.rfBubble.arguments[0], core.rfBubble.rsData, core.rfBubble.arguments[2]);
        return core.rfBubble.rsData + core.rfBubble.arguments[2];
    }, function (core) {
        return null;
    }, function (core) {
        console.log("WB ADDI ", core.tcBubble.arguments[0], core.tcBubble.aluOut);
        core.registerFile.write(core.tcBubble.arguments[0], core.tcBubble.aluOut);
        return 0;
    }));
    //I-Branch Subtype
    formats.push(new Format("IB", [
        new BitRange("opcode", 26, 6),
        new BitRange("rs", 21, 5, 0),
        new BitRange("rt", 16, 5, 1),
        new BitRange("imm", 0, 16, 2)
    ], ["rt", "rs", "imm"], [Parameter.register, Parameter.register, Parameter.special], /[a-zA-Z]+\s*(\$[A-Za-z0-9]+)\s*,\s*(\$[A-Za-z0-9]+)\s*,\s*(-?[a-zA-Z0-9_]+)/, "@mnem @arg, @arg, @arg", 0, 1, function (address, text, bits, labels, addresses) {
        var array = text.split(""); //Character View
        var result = {
            errorMessage: null,
            value: null
        };
        var int = NaN;
        var labelLocation = labels.indexOf(text);
        if (labelLocation !== -1) {
            int = addresses[labelLocation];
        }
        else {
            var radix = 10 >>> 0;
            var splice = false;
            if (array[0] === "0") {
                if (array[1] == "b") {
                    radix = 2;
                    splice = true;
                }
                if (array[1] == "o") {
                    radix = 8;
                    splice = true;
                }
                if (array[1] == "d") {
                    radix = 10;
                    splice = true;
                }
                if (array[1] == "x") {
                    radix = 16;
                    splice = true;
                }
            }
            var interpretable = text;
            if (splice) {
                interpretable = array.splice(2, array.length - 2).join("");
            }
            int = parseInt(interpretable, radix);
        }
        if (isNaN(int)) {
            result.errorMessage = "Offset '" + text + "' is not a recognized label or literal.";
            return result;
        }
        if ((int & 3) != 0) {
            result.errorMessage = "Branches must be word-aligned.";
            return result;
        }
        int -= address;
        int >>= 2;
        if (rangeCheck(int, 16)) {
            result.value = int;
            return result;
        }
        result.errorMessage = "The value of '" + text + "' is out of range.";
        return result;
    }, function (value, address) {
        return value << 2;
    }));
    var ibSubtype = formats[formats.length - 1];
    instructions.push(new Instruction("BEQ", ibSubtype, ["opcode"], [0x04], function (core) {
        return (core.rfBubble.rsData == core.rfBubble.rtData) ? 1 : 0;
    }, function (core) {
        return null;
    }, function (core) {
        return null;
    }));
    instructions.push(new Instruction("BNE", ibSubtype, ["opcode"], [0x05], function (core) {
        return (core.rfBubble.rsData != core.rfBubble.rtData) ? 1 : 0;
    }, function (core) {
        return null;
    }, function (core) {
        return null;
    }));
    instructions.push(new Instruction("BLE", ibSubtype, ["opcode"], [0x06], function (core) {
        return (core.rfBubble.rsData <= core.rfBubble.rtData) ? 1 : 0;
    }, function (core) {
        return null;
    }, function (core) {
        return null;
    }));
    //I Load/Store Subtype
    formats.push(new Format("ILS", [
        new BitRange("opcode", 26, 6),
        new BitRange("rs", 21, 5, 2),
        new BitRange("rt", 16, 5, 0),
        new BitRange("imm", 0, 16, 1)
    ], ["rt", "imm", "rs"], [Parameter.register, Parameter.immediate, Parameter.register], /[a-zA-Z]+\s*(\$[A-Za-z0-9]+)\s*,\s*(-?0?[boxd]?[0-9A-F]+)\s*\(\s*(\$[A-Za-z0-9]+)\s*\)/, "@mnem @arg, @arg(@arg)"));
    var ilsSubtype = formats[formats.length - 1];
    //TO-DO: Verify function(core) functionality
    instructions.push(new Instruction("LW", ilsSubtype, ["opcode"], [0x23], function (core) {
        core.rd = core.rfBubble.arguments[0];
        return core.rfBubble.rsData + core.rfBubble.arguments[1];
    }, function (core) {
        var bytes = core.memcpy(core.df1Bubble.aluOut, 4);
        if (bytes == null) {
            alert("Loaded 4 null bytes");
            return -1;
        }
        core.df2Bubble.readData = catBytes(bytes);
        console.log("read data" + core.df2Bubble.readData);
        return 0;
    }, function (core) {
        console.log("LW WB: ", core.tcBubble.arguments[0], " => ", core.tcBubble.readData, " at ", core.tcBubble.aluOut);
        core.registerFile.write(core.tcBubble.arguments[0], core.tcBubble.readData);
        return 0;
    }));
    instructions.push(new Instruction("SW", ilsSubtype, ["opcode"], [0x2B], function (core) {
        core.rd = core.rfBubble.arguments[0];
        return core.rfBubble.rsData + core.rfBubble.arguments[1];
    }, function (core) {
        var bytes = [];
        var value = core.df1Bubble.rtData;
        console.log("rtData @ sw " + core.df1Bubble.aluOut + ": " + value);
        bytes.push(value & 255);
        value = value >>> 8;
        bytes.push(value & 255);
        value = value >>> 8;
        bytes.push(value & 255);
        value = value >>> 8;
        bytes.push(value & 255);
        console.log(core.df1Bubble.aluOut, bytes);
        if (core.memset(core.df1Bubble.aluOut, bytes)) {
            return 0;
        }
        return -1;
    }, function (core) {
        return null;
    }));
    //J-Type
    formats.push(new Format("J", [
        new BitRange("opcode", 26, 6),
        new BitRange("imm", 0, 26, 0, null, 32)
    ], ["imm"], [Parameter.special], /[A-z]+\s*([A-Za-z0-9_]+)/, "@mnem @arg", 0, 0, function (address, text, bits, labels, addresses) {
        var array = text.split(""); //Character View
        var result = {
            errorMessage: null,
            value: null
        };
        var int = NaN;
        var labelLocation = labels.indexOf(text);
        if (labelLocation !== -1) {
            int = addresses[labelLocation];
        }
        else {
            var radix = 10 >>> 0;
            var splice = false;
            if (array[0] === "0") {
                if (array[1] == "b") {
                    radix = 2;
                    splice = true;
                }
                if (array[1] == "o") {
                    radix = 8;
                    splice = true;
                }
                if (array[1] == "d") {
                    radix = 10;
                    splice = true;
                }
                if (array[1] == "x") {
                    radix = 16;
                    splice = true;
                }
            }
            var interpretable = text;
            if (splice) {
                interpretable = array.splice(2, array.length - 2).join("");
            }
            int = parseInt(interpretable, radix);
        }
        if (isNaN(int)) {
            result.errorMessage = "Offset '" + text + "' is not a recognized label or literal.";
            return result;
        }
        if ((int >>> 28) == (address >>> 28)) {
            if ((int & 3) == 0) {
                result.value = (int & 0x0ffffffc) >>> 2;
                return result;
            }
            result.errorMessage = "Jumps must be word-aligned.";
            return result;
        }
        result.errorMessage = "The value of '" + text + "' is out of range.";
        return result;
    }, function (value, address) {
        return (value << 2) | (address & 0xf0000000);
    }));
    var jType = formats[formats.length - 1];
    instructions.push(new Instruction("J", jType, ["opcode"], [0x2], function (core) {
        return null;
    }, function (core) {
        return null;
    }, function (core) {
        return null;
    }));
    instructions.push(new Instruction("JAL", jType, ["opcode"], [0x3], function (core) {
        return null;
    }, function (core) {
        return null;
    }, function (core) {
        core.registerFile.write(31, core.tcBubble.pc);
        return 0;
    }));
    instructions.push(new Instruction("JUMP_PROCEDURE", jType, ["opcode"], [0x63], function (core) {
        return null;
    }, function (core) {
        return null;
    }, function (core) {
        return null;
    }));
    instructions.push(new Instruction("RETURN_PROCEDURE", jType, ["opcode"], [0x64], function (core) {
        return null;
    }, function (core) {
        return null;
    }, function (core) {
        return null;
    }));
    /*
        ARGUMENT PROCESSOR
        Does what it says on the tin. It needs quite a bit of information, but otherwise successfully interprets
        any MIPS argument.
    */
    var process = function (address, text, type, bits, labels, addresses) {
        var array = text.split(""); //Character View
        var result = {
            errorMessage: null,
            value: null
        };
        switch (type) {
            case Parameter.register:
                var registerNo;
                var index = this.abiNames.indexOf(text);
                if (index !== -1) {
                    result.value = index;
                    return result;
                }
                if (array[0] !== "$") {
                    result.errorMessage = "Register " + text + " does not exist.";
                    return result;
                }
                registerNo = parseInt(array.splice(1, array.length - 1).join(""));
                if (0 <= registerNo && registerNo <= 31) {
                    result.value = registerNo;
                    return result;
                }
                else {
                    result.errorMessage = "Register " + text + " does not exist.";
                    return result;
                }
            case Parameter.immediate:
                //Label
                var int = NaN;
                var labelIndex = labels.indexOf(text);
                if (labelIndex !== -1) {
                    int = addresses[labelIndex];
                }
                else if (array.length === 3 && (array[0] == "\'") && (array[2] == "\'")) {
                    int = array[1].charCodeAt(0);
                }
                else {
                    var radix = 10 >>> 0;
                    var splice = false;
                    if (array[0] === "0") {
                        if (array[1] == "b") {
                            radix = 2;
                            splice = true;
                        }
                        if (array[1] == "o") {
                            radix = 8;
                            splice = true;
                        }
                        if (array[1] == "d") {
                            radix = 10;
                            splice = true;
                        }
                        if (array[1] == "x") {
                            radix = 16;
                            splice = true;
                        }
                    }
                    var interpretable = text;
                    if (splice) {
                        interpretable = array.splice(2, array.length - 2).join("");
                    }
                    int = parseInt(interpretable, radix);
                }
                if (isNaN(int)) {
                    result.errorMessage = "Immediate '" + text + "' is not a recognized label, literal or character.";
                    return result;
                }
                if (rangeCheck(int, bits)) {
                    result.value = int;
                    return result;
                }
                result.errorMessage = "The value of '" + text + "' is out of range.";
                return result;
            case Parameter.offset:
                var int = NaN;
                var labelLocation = labels.indexOf(text);
                if (labelLocation !== -1) {
                    int = addresses[labelLocation] - address;
                }
                else {
                    var radix = 10 >>> 0;
                    var splice = false;
                    if (array[0] === "0") {
                        if (array[1] == "b") {
                            radix = 2;
                            splice = true;
                        }
                        if (array[1] == "o") {
                            radix = 8;
                            splice = true;
                        }
                        if (array[1] == "d") {
                            radix = 10;
                            splice = true;
                        }
                        if (array[1] == "x") {
                            radix = 16;
                            splice = true;
                        }
                    }
                    var interpretable = text;
                    if (splice) {
                        interpretable = array.splice(2, array.length - 2).join("");
                    }
                    int = parseInt(interpretable, radix);
                }
                if (isNaN(int)) {
                    result.errorMessage = "Offset '" + text + "' is not a recognized label or literal.";
                    return result;
                }
                if (rangeCheck(int, bits)) {
                    result.value = int;
                    return result;
                }
                result.errorMessage = "The value of '" + text + "' is out of range.";
                return result;
            default:
                return result;
        }
    };
    /*
        TOKENIZER

        This is the assembler's "first pass" -it does
        primtive lexical analysis and creates an
        address table.
    */
    var tokenize = function (file) {
        var result = {
            errorMessage: null,
            labels: [],
            addresses: [],
            lines: [],
            pc: []
        };
        var address = 0;
        var text = true;
        var lines = file.split("\n");
        for (var i = 0; i < lines.length; i++) {
            var labelExtractor = /\s*(([A-Za-z_][A-Za-z0-9_]*):)?(.*)?/.exec(lines[i]);
            if (labelExtractor == null) {
                console.log("Congratulations, you broke regular expressions.");
            }
            if (typeof labelExtractor[2] !== 'undefined') {
                result.labels.push(labelExtractor[2]);
                result.addresses.push(address);
            }
            lines[i] = labelExtractor[3];
            if (lines[i] == undefined) {
                continue;
            }
            var chars = lines[i].split("");
            //Check for unterminated string/char (also comments)
            var inString = false;
            var commentOut = false;
            //Comments
            for (var j = 0; j < chars.length; j++) {
                if (!commentOut) {
                    if (chars[j] == "\"" || chars[j] == "\'") {
                        inString = !inString;
                    }
                    else if (inString) {
                        if (chars[j] == "\\") {
                            j++; //Escape next character
                        }
                        else if (chars[j] == "\n") {
                            result.errorMessage = "Line " + i + ": Unterminated string.";
                            return result;
                        }
                    }
                    else {
                        if (chars[j] == "#") {
                            commentOut = true;
                            chars.splice(j, 1);
                            j--;
                        }
                    }
                }
                else {
                    if (chars[j] !== "\n") {
                        chars.splice(j, 1);
                        j--;
                    }
                    else {
                        commentOut = false;
                    }
                }
            }
            lines[i] = chars.join("");
            lines[i] = lines[i].split("' '").join("32");
            //These are fine for most purposes, but string directives MUST NOT USE THE ARRAY DIRECTIVES BY ANY MEANS.
            var directives = lines[i].split(" ").filter(function (value) { return value.length > 0; });
            //Check if whitespace
            if (directives.length === 0) {
                continue;
            }
            var directiveChars = directives[0].split("");
            //Calculate size in bytes
            if (text) {
                if (directives[0] === ".data") {
                    text = false;
                    if (directives[1] !== undefined) {
                        result.errorMessage = "Line " + i + ": " + directives[1] + " is extraneous. .data does not take any arguments.";
                        return result;
                    }
                }
                else if (directives[0] === ".text") {
                    //Do nothing.
                }
                else if (directiveChars[0] === ".") {
                    result.errorMessage = "Line " + i + ": " + directives[0] + " cannot be in the text section. Aborting.";
                    return result;
                }
                else {
                    address += 4;
                    var instructionIndex = this.mnemonicSearch(directives[0].toUpperCase());
                    if (instructionIndex === -1) {
                        result.errorMessage = "Line " + i + ": Instruction " + directives[0] + " not found.";
                        return result;
                    }
                }
            }
            else {
                if (directives[0] == ".text") {
                    text = true;
                    if (directives[1] !== undefined) {
                        result.errorMessage = "Line " + i + ": " + directives[1] + " is extraneous. .text does not take any arguments.";
                        return result;
                    }
                }
                else if (directives[0] === ".data") {
                    //Do nothing.
                }
                else if (this.dataDirectives.indexOf(directives[0]) !== -1) {
                    var index = this.dataDirectives.indexOf(directives[0]);
                    if (this.dataDirectiveSizes[index] !== 0) {
                        var array = directives.join(" ").split(directives[i]).join("").split(",");
                        address += array.length * this.dataDirectiveSizes[index];
                    }
                    else {
                        switch (directives[0]) {
                            case ".asciiz":
                            case ".ascii":
                                var match = /.([A-Za-z]+?)\s*\"(.*)\"\s*(#.*)?$/.exec(lines[i]);
                                if (match == null) {
                                    result.errorMessage = "Line " + i + ": Malformed string directive.";
                                    return result;
                                }
                                var array = match[1].split("");
                                for (var j = 0; j < array.length; j++) {
                                    if (array[j] == "\\") {
                                        j++;
                                    }
                                    address += 1;
                                }
                                if (directives[0] == ".asciiz") {
                                    address += 1;
                                }
                        }
                    }
                }
                else if (directiveChars[0] === ".") {
                    result.errorMessage = "Line " + i + ": Unsupported directive " + directives[0] + ".";
                    return result;
                }
                else {
                    result.errorMessage = "Line " + i + ": Unrecognized keyword " + directives[0] + ".";
                    return result;
                }
            }
            result.pc.push(address);
        }
        result.lines = lines;
        return result;
    };
    /*
       ASSEMBLER
       This is the fun part.
   */
    var assemble = function (nester, address, lines, labels, addresses) {
        if (nester === void 0) { nester = null; }
        var result = {
            errorMessage: null,
            machineCode: [],
            size: 0
        };
        var text = true;
        for (var i = 0; i < lines.length; i++) {
            if (typeof lines[i] == 'undefined') {
                continue;
            }
            var directives = lines[i].split(" ").filter(function (value) { return value.length > 0; });
            //Check if whitespace
            if (directives.length === 0) {
                continue;
            }
            if (text) {
                if (directives[0] === ".data") {
                    text = false;
                }
                else if (directives[0] === ".text") {
                    //\_(ツ)_/
                }
                else {
                    address += 4;
                    var instructionIndex = this.mnemonicSearch(directives[0].toUpperCase());
                    if (instructionIndex === -1) {
                        result.errorMessage = "Line " + ((nester == null) ? "" : (nester + ":")) + i + ": Instruction " + directives[0] + " not found.";
                        return result;
                    }
                    var instruction = this.instructions[instructionIndex];
                    var format = instruction.format;
                    var bitRanges = format.ranges;
                    var regex = format.regex;
                    var params = format.parameters;
                    var paramTypes = format.parameterTypes;
                    var machineCode = instruction.template();
                    var match = regex.exec(lines[i]);
                    if (match == null) {
                        result.errorMessage = "Line " + ((nester == null) ? "" : (nester + ":")) + i + ": Argument format for " + directives[0] + " violated.";
                        return result;
                    }
                    var args = match.splice(1, params.length);
                    for (var j = 0; j < bitRanges.length; j++) {
                        if (bitRanges[j].parameter != null) {
                            var startBit = 0;
                            var endBit = null;
                            var bits = bitRanges[j].bits;
                            var field = bitRanges[j].field;
                            var limits = /([A-za-z]+)\s*\[\s*(\d+)\s*:\s*(\d+)\s*\]/.exec(bitRanges[j].field);
                            if (limits != null) {
                                field = limits[1];
                                bits = bitRanges[j].limitlessBits;
                            }
                            var index = format.fieldParameterIndex(field);
                            var register = 0;
                            if (paramTypes[index] !== Parameter.special) {
                                var processed_1 = this.processParameter(address, args[bitRanges[j].parameter], paramTypes[index], bits, labels, addresses);
                                if (processed_1.errorMessage !== null) {
                                    result.errorMessage = "Line " + ((nester == null) ? "" : (nester + ":")) + i + ": " + processed_1.errorMessage;
                                    return result;
                                }
                                register = processed_1.value;
                            }
                            else {
                                var processed_2 = instruction.format.processSpecialParameter(address, args[index], bits, labels, addresses);
                                if (processed_2.errorMessage !== null) {
                                    result.errorMessage = "Line " + ((nester == null) ? "" : (nester + ":")) + i + ": " + processed_2.errorMessage;
                                    return result;
                                }
                                register = processed_2.value;
                            }
                            if (limits != null) {
                                startBit = parseInt(limits[3]);
                                endBit = parseInt(limits[2]);
                                register = register >>> startBit;
                                register = register & ((1 << (endBit - startBit + 1)) - 1);
                            }
                            machineCode = machineCode | ((register & ((1 << bitRanges[j].bits) - 1)) << bitRanges[j].start);
                        }
                    }
                    for (var j = 0; j < 4; j++) {
                        result.machineCode.push(machineCode & 255);
                        machineCode = machineCode >>> 8;
                    }
                }
            }
            else {
                if (directives[0] == ".text") {
                    text = true;
                }
                else if (this.dataDirectives.indexOf(directives[0]) !== -1) {
                    var index = this.dataDirectives.indexOf(directives[0]);
                    if (this.dataDirectiveSizes[index] !== 0) {
                        var size = this.dataDirectiveSizes[index];
                        var array = lines[i].split("' '").join("'$OAK_SPACE_TEMP'").split(directives[0]).join("").split(" ").join("").split("'$OAK_SPACE_TEMP'").join("' '").split(",");
                        for (var j = 0; j < array.length; j++) {
                            var processed = this.processParameter(address, array[j], Parameter.immediate, size * 8, labels, addresses);
                            if (processed.errorMessage !== null) {
                                result.errorMessage = "Line " + ((nester == null) ? "" : (nester + ":")) + i + ": " + processed.errorMessage;
                                return result;
                            }
                            for (var k = 0; k < size; k++) {
                                address += 1;
                                result.machineCode.push(processed.value & 255);
                                processed.value = processed.value >>> 8;
                            }
                        }
                    }
                    else {
                        switch (directives[0]) {
                            case ".asciiz":
                            case ".ascii":
                                var stringMatch = /.([A-Za-z]+?)\s*\"(.*)\"\s*(#.*)?$/.exec(lines[i]);
                                if (stringMatch == null) {
                                    result.errorMessage = "Line " + i + ": Malformed string directive.";
                                    return result;
                                }
                                if (stringMatch[1] == undefined) {
                                    stringMatch[1] = "";
                                }
                                var characters = stringMatch[1].split("");
                                for (var j = 0; j < characters.length; j++) {
                                    if (characters[j] == "\\") {
                                        j++;
                                        if (j + 1 < characters.length) {
                                            switch (characters[j + 1]) {
                                                case 'n':
                                                    result.machineCode.push(10 >>> 0);
                                                    break;
                                                case '0':
                                                    result.machineCode.push(0 >>> 0);
                                                    break;
                                                case "'":
                                                    result.machineCode.push(39 >>> 0);
                                                    break;
                                                case "\\":
                                                    result.machineCode.push(92 >>> 0);
                                                    break;
                                                default:
                                                    result.machineCode.push(characters[j].charCodeAt(0));
                                            }
                                        }
                                    }
                                    else {
                                        result.machineCode.push(characters[j].charCodeAt(0));
                                    }
                                    address += 1;
                                }
                                if (directives[0] == ".asciiz") {
                                    result.machineCode.push(0 >>> 0);
                                    address += 1;
                                }
                        }
                    }
                }
            }
        }
        result.size = address;
        return result;
    };
    var abiNames = ["$zero", "$at", "$v0", "$v1", "$a0", "$a1", "$a2", "$a3", "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7", "$s0", "$s1", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7", "$t8", "$t9", "$k0", "$k1", "$gp", "$sp", "$fp", "$ra"];
    return new InstructionSet("mips", 32, formats, instructions, [".word", ".half", ".byte", ".asciiz"], [4, 2, 1, 0], abiNames, process, tokenize, assemble);
}
var MIPS = Oak_gen_MIPS();
var MIPSRegisterFile = (function () {
    function MIPSRegisterFile(memorySize, abiNames) {
        this.physicalFile = [];
        this.modifiedRegisters = [];
        for (var i = 0; i < 32; i++) {
            this.physicalFile.push(0);
            this.modifiedRegisters.push(false);
        }
        this.memorySize = memorySize;
        this.physicalFile[29] = memorySize; //stack pointer
        this.abiNames = abiNames;
    }
    MIPSRegisterFile.prototype.print = function () {
        console.log("Registers\n------");
        for (var i = 0; i < 32; i++) {
            console.log("$" + i.toString(), this.abiNames[i], this.physicalFile[i].toString(), (this.physicalFile[i] >>> 0).toString(16).toUpperCase());
        }
        console.log("------");
    };
    MIPSRegisterFile.prototype.read = function (registerNumber) {
        if (registerNumber === 0) {
            return 0;
        }
        else {
            return this.physicalFile[registerNumber];
        }
    };
    MIPSRegisterFile.prototype.write = function (registerNumber, value) {
        this.physicalFile[registerNumber] = value;
        this.modifiedRegisters[registerNumber] = true;
    };
    MIPSRegisterFile.prototype.getRegisterCount = function () {
        return 32;
    };
    MIPSRegisterFile.prototype.getModifiedRegisters = function () {
        var modReg = this.modifiedRegisters.slice();
        for (var i = 0; i < this.getRegisterCount(); i++) {
            this.modifiedRegisters[i] = false;
        }
        return modReg;
    };
    MIPSRegisterFile.prototype.reset = function () {
        for (var i = 0; i < 32; i++) {
            this.physicalFile[i] = 0;
            this.modifiedRegisters[i] = false;
        }
        this.physicalFile[29] = this.memorySize;
    };
    return MIPSRegisterFile;
}());
;
var BranchPredictor = (function () {
    function BranchPredictor() {
        this.state = 0 >>> 0;
    }
    BranchPredictor.prototype.sendResult = function (branched) {
        if (branched) {
            this.state -= 1;
            if (this.state < 0) {
                this.state = 0;
            }
        }
        else {
            this.state += 1;
            if (this.state > 3) {
                this.state = 3;
            }
        }
    };
    BranchPredictor.prototype.getPrediction = function () {
        return (((this.state >> 1) & 1) != 1);
    };
    return BranchPredictor;
}());
var MIPSCore //: Core
 = (function () {
    function MIPSCore(memorySize, ecall, instructionCallback, addCycle, clearPipeline) {
        this.stack = [0, 0, 0, 0];
        //Inter-stage buffers
        this.ifBubble = {
            pc: null,
            fetched: null,
            text: null,
            instruction: null,
            arguments: null,
            valid: false
        };
        this.isBubble = {
            pc: null,
            fetched: null,
            text: null,
            instruction: null,
            arguments: null,
            valid: false
        };
        this.rfBubble = {
            pc: null,
            fetched: null,
            text: null,
            instruction: null,
            arguments: null,
            valid: false,
            rsData: null,
            rtData: null
        };
        this.eBubble = {
            pc: null,
            fetched: null,
            text: null,
            instruction: null,
            arguments: null,
            valid: false,
            rsData: null,
            rtData: null,
            aluOut: null,
            rd: null,
            stall: false
        };
        this.df1Bubble = {
            pc: null,
            fetched: null,
            text: null,
            instruction: null,
            arguments: null,
            valid: false,
            rsData: null,
            rtData: null,
            aluOut: null,
            rd: null,
            readData: null
        };
        this.df2Bubble = {
            pc: null,
            fetched: null,
            text: null,
            instruction: null,
            arguments: null,
            valid: false,
            rsData: null,
            rtData: null,
            aluOut: null,
            rd: null,
            readData: null
        };
        this.tcBubble = {
            pc: null,
            fetched: null,
            text: null,
            instruction: null,
            arguments: null,
            valid: false,
            rsData: null,
            rtData: null,
            aluOut: null,
            rd: null,
            readData: null
        };
        this.wbBubble = {
            instruction: null
        };
        this.stall = false;
        this.instructionSet = MIPS;
        this.memorySize = memorySize;
        this.registerFile = new MIPSRegisterFile(memorySize, MIPS.abiNames);
        this.predictor = new BranchPredictor();
        this.ecall = ecall;
        this.instructionCallback = instructionCallback;
        this.addCycle = addCycle;
        this.clearPipeline = clearPipeline;
        this.reset();
    }
    //Returns bytes on success, null on failure
    MIPSCore.prototype.memcpy = function (address, bytes) {
        if (address + bytes > this.memorySize) {
            return null;
        }
        var result = [];
        for (var i = 0; i < bytes; i++) {
            result.push(this.memory[address + i]);
        }
        return result;
    };
    //Returns boolean indicating success
    //Use to store machine code in memory so it can be executed.
    MIPSCore.prototype.memset = function (address, bytes) {
        if (address < 0) {
            return false;
        }
        if (address + bytes.length > this.memorySize) {
            return false;
        }
        for (var i = 0; i < bytes.length; i++) {
            this.memory[address + i] = bytes[i];
        }
        return true;
    };
    MIPSCore.prototype.fetchAndDecode = function () {
        var result = {
            fetched: null,
            text: null,
            instruction: null,
            arguments: null,
            error: null
        };
        if (this.pc < 0) {
            result.error = "Fetch Error: Negative program counter.";
            return result;
        }
        var arr = this.memcpy(this.pc, 4);
        if (arr == null) {
            result.error = "Fetch Error: Illegal memory access.";
            return result;
        }
        this.pcNext = this.pc + 4;
        var fetched = catBytes(arr);
        var insts = this.instructionSet.instructions;
        var decoded = null;
        var args = [];
        for (var i = 0; i < insts.length; i++) {
            if (insts[i].match(fetched)) {
                decoded = insts[i];
                break;
            }
        }
        if (decoded == null) {
            result.error = "Address 0x" + (this.pc - 4).toString(16).toUpperCase() + ": Instruction unrecognized or unsupported.";
            return result;
        }
        var format = decoded.format;
        var bitRanges = format.ranges;
        var params = format.parameters;
        var paramTypes = format.parameterTypes;
        for (var i = 0; i < bitRanges.length; i++) {
            if (bitRanges[i].parameter != null) {
                var limit = 0;
                var field = bitRanges[i].field;
                var limits = /([A-za-z]+)\s*\[\s*(\d+)\s*:\s*(\d+)\s*\]/.exec(bitRanges[i].field);
                if (limits != null) {
                    field = limits[1];
                    limit = parseInt(limits[3]) >>> 0;
                }
                var index = format.fieldParameterIndex(field);
                var bits = bitRanges[i].bits;
                var value = ((fetched >>> bitRanges[i].start) & ((1 << bitRanges[i].bits) - 1)) << limit;
                if (paramTypes[index] === Parameter.special) {
                    value = decoded.format.decodeSpecialParameter(value, this.pcNext); //Unmangle...
                }
                args[bitRanges[i].parameter] = args[bitRanges[i].parameter] | value;
            }
        }
        for (var i = 0; i < params.length; i++) {
            var rangeIndex = format.parameterBitRangeIndex(params[i]);
            if (rangeIndex === -1) {
                console.log("Internal error: No field found for parameter " + params[i] + ".");
            }
            var bits = bitRanges[rangeIndex].bits;
            if (bitRanges[rangeIndex].limitlessBits != null) {
                bits = bitRanges[rangeIndex].limitlessBits;
            }
            if (decoded.signed && paramTypes[i] != Parameter.register) {
                args[i] = signExt(args[i], bits);
            }
        }
        //Jumping in Fetch is probably the easiest way to handle it
        if (decoded.format.name == "J") {
            if (decoded.mnemonic == "JUMP_PROCEDURE") {
                if (this.stackPointer >= 3) {
                    return "Jump procedure stack overflow.";
                }
                this.stackPointer += 1;
                this.stack[this.stackPointer] = this.pcNext;
            }
            if (decoded.mnemonic == "RETURN_PROCEDURE") {
                if (this.stackPointer < 0) {
                    return "Return procedure stack underflow.";
                }
                this.stackPointer -= 1;
            }
            this.pcNext = args[0];
        }
        //Branching here
        result =
            {
                fetched: fetched,
                text: format.disassemble(decoded.mnemonic, args, this.instructionSet.abiNames),
                instruction: decoded,
                arguments: args,
                error: null
            };
        return result;
    };
    MIPSCore.prototype.passIFIS = function () {
        this.isBubble.arguments = this.ifBubble.arguments;
        this.isBubble.fetched = this.ifBubble.fetched;
        this.isBubble.instruction = this.ifBubble.instruction;
        this.isBubble.pc = this.ifBubble.pc;
        this.isBubble.text = this.ifBubble.text;
        this.isBubble.valid = this.ifBubble.valid;
    };
    MIPSCore.prototype.passISRF = function () {
        this.rfBubble.arguments = this.isBubble.arguments;
        this.rfBubble.fetched = this.isBubble.fetched;
        this.rfBubble.instruction = this.isBubble.instruction;
        this.rfBubble.pc = this.isBubble.pc;
        this.rfBubble.text = this.isBubble.text;
        this.rfBubble.valid = this.isBubble.valid;
        var rt = this.isBubble.fetched >> 16 & 31;
        var rs = this.isBubble.fetched >> 21 & 31;
    };
    MIPSCore.prototype.passRFEX = function () {
        this.eBubble.arguments = this.rfBubble.arguments;
        this.eBubble.fetched = this.rfBubble.fetched;
        this.eBubble.instruction = this.rfBubble.instruction;
        this.eBubble.pc = this.rfBubble.pc;
        this.eBubble.text = this.rfBubble.text;
        this.eBubble.valid = this.rfBubble.valid;
        if (this.eBubble.valid) {
            this.eBubble.aluOut = this.rfBubble.instruction.executor(this);
            this.eBubble.rd = this.rd;
        }
        this.eBubble.rsData = this.rfBubble.rsData;
        this.eBubble.rtData = this.rfBubble.rtData;
    };
    MIPSCore.prototype.passEXDF = function () {
        this.df1Bubble.arguments = this.eBubble.arguments;
        this.df1Bubble.fetched = this.eBubble.fetched;
        this.df1Bubble.instruction = this.eBubble.instruction;
        this.df1Bubble.pc = this.eBubble.pc;
        this.df1Bubble.text = this.eBubble.text;
        this.df1Bubble.valid = this.eBubble.valid;
        this.df1Bubble.rsData = this.eBubble.rsData;
        this.df1Bubble.rtData = this.eBubble.rtData;
        this.df1Bubble.aluOut = this.eBubble.aluOut;
        this.df1Bubble.rd = this.eBubble.rd;
    };
    MIPSCore.prototype.passDFDS = function () {
        this.df2Bubble.arguments = this.df1Bubble.arguments;
        this.df2Bubble.fetched = this.df1Bubble.fetched;
        this.df2Bubble.instruction = this.df1Bubble.instruction;
        this.df2Bubble.pc = this.df1Bubble.pc;
        this.df2Bubble.text = this.df1Bubble.text;
        this.df2Bubble.valid = this.df1Bubble.valid;
        this.df2Bubble.rsData = this.df1Bubble.rsData;
        this.df2Bubble.rtData = this.df1Bubble.rtData;
        this.df2Bubble.aluOut = this.df1Bubble.aluOut;
        this.df2Bubble.rd = this.df1Bubble.rd;
    };
    MIPSCore.prototype.passDSTC = function () {
        this.tcBubble.arguments = this.df2Bubble.arguments;
        this.tcBubble.fetched = this.df2Bubble.fetched;
        this.tcBubble.instruction = this.df2Bubble.instruction;
        this.tcBubble.pc = this.df2Bubble.pc;
        this.tcBubble.text = this.df2Bubble.text;
        this.tcBubble.valid = this.df2Bubble.valid;
        this.tcBubble.rsData = this.df2Bubble.rsData;
        this.tcBubble.rtData = this.df2Bubble.rtData;
        this.tcBubble.aluOut = this.df2Bubble.aluOut;
        this.tcBubble.rd = this.df2Bubble.rd;
    };
    MIPSCore.prototype.passTCWB = function () {
        this.wbBubble.instruction = this.tcBubble.instruction;
    };
    MIPSCore.prototype.parseFetched = function (fetchOut) {
        if (fetchOut.instruction)
            this.ifBubble.valid = fetchOut.instruction.mnemonic != "NOP";
        this.ifBubble.arguments = fetchOut.arguments;
        this.ifBubble.fetched = fetchOut.fetched;
        this.ifBubble.instruction = fetchOut.instruction;
        this.ifBubble.text = fetchOut.text;
        this.ifBubble.pc = this.pc;
    };
    MIPSCore.prototype.forwardUnit = function () {
        var rt = this.rfBubble.fetched >> 16 & 31;
        var rs = this.rfBubble.fetched >> 21 & 31;
        this.rfBubble.rsData = this.registerFile.read(rs);
        this.rfBubble.rtData = this.registerFile.read(rt);
        if (rt == this.eBubble.rd && this.eBubble.valid) {
            this.rfBubble.rtData = this.eBubble.aluOut;
        }
        else if (rt == this.df1Bubble.rd && this.df1Bubble.valid) {
            this.rfBubble.rtData = this.df1Bubble.aluOut;
        }
        else if (rt == this.df2Bubble.rd && this.df2Bubble.valid) {
            this.rfBubble.rtData = this.df2Bubble.aluOut;
        }
        if (rs == this.eBubble.rd && this.eBubble.valid) {
            this.rfBubble.rsData = this.eBubble.aluOut;
        }
        else if (rs == this.df1Bubble.rd && this.df1Bubble.valid) {
            this.rfBubble.rsData = this.df1Bubble.aluOut;
        }
        else if (rs == this.df2Bubble.rd && this.df2Bubble.valid) {
            this.rfBubble.rsData = this.df2Bubble.aluOut;
        }
        console.log("Forward RT:", this.rfBubble.rtData, " RS: ", this.rfBubble.rsData);
    };
    MIPSCore.prototype.stallUnit = function () {
        this.stall = false;
        if (this.rfBubble.valid) {
            var rt_D = this.rfBubble.fetched >> 16 & 31;
            var rs_D = this.rfBubble.fetched >> 21 & 31;
            //At end of execution stall_E
            if (this.eBubble.valid) {
                var rt_E = this.eBubble.fetched >> 16 & 31;
                var rs_E = this.eBubble.fetched >> 21 & 31;
                this.stall = this.stall || (((rt_D == rt_E) || (rs_D == rt_E)) && this.eBubble.instruction.mnemonic == "LW");
            }
            if (this.df1Bubble.valid) {
                var rt_E = this.df1Bubble.fetched >> 16 & 31;
                var rs_E = this.df1Bubble.fetched >> 21 & 31;
                this.stall = this.stall || (((rt_D == rt_E) || (rs_D == rt_E)) && this.df1Bubble.instruction.mnemonic == "LW");
            }
            if (this.df2Bubble.valid) {
                var rt_E = this.df2Bubble.fetched >> 16 & 31;
                var rs_E = this.df2Bubble.fetched >> 21 & 31;
                this.stall = this.stall || (((rt_D == rt_E) || (rs_D == rt_E)) && this.df2Bubble.instruction.mnemonic == "LW");
            }
        }
    };
    //Equivalent to one clock cycle.
    MIPSCore.prototype.cycle = function () {
        var fetchOut = this.fetchAndDecode();
        console.log(this.pc, fetchOut);
        this.stallUnit();
        // Do writeback early because it uses tcBubble.
        if (this.tcBubble.instruction)
            this.tcBubble.instruction.writeBack(this);
        // Pass Data
        this.writeBackValid = this.tcBubble.valid;
        this.passDSTC();
        this.passDFDS();
        if (this.df2Bubble.instruction)
            this.df2Bubble.instruction.memory(this);
        //if (!this.stall) {
        this.passEXDF();
        this.forwardUnit();
        this.passRFEX();
        this.passISRF();
        this.passIFIS();
        /*}
        else {
            this.ifBubble.valid = false;
        }*/
        // Move Fetched
        this.parseFetched(fetchOut);
        var bubbles = [this.ifBubble, this.isBubble, this.rfBubble, this.eBubble, this.df1Bubble, this.df2Bubble, this.tcBubble];
        console.log(bubbles);
        //if (!this.stall) {
        this.pcNext = this.pc += 4;
        this.pc = this.pcNext;
        //}
        this.cycleCounter += 1;
        return null;
    };
    MIPSCore.prototype.reset = function () {
        this.pc = 0 >>> 0;
        this.memory = [];
        for (var i = 0; i < this.memorySize; i++) {
            this.memory[i] = 0;
        }
        this.registerFile.reset();
        this.writeBackValid = false;
        this.ifBubble =
            {
                pc: null,
                fetched: null,
                text: null,
                instruction: null,
                arguments: null,
                valid: false
            };
        this.isBubble =
            {
                pc: null,
                fetched: null,
                text: null,
                instruction: null,
                arguments: null,
                valid: false
            };
        this.rfBubble =
            {
                pc: null,
                fetched: null,
                text: null,
                instruction: null,
                arguments: null,
                valid: false,
                rsData: null,
                rtData: null
            };
        this.eBubble =
            {
                pc: null,
                fetched: null,
                text: null,
                instruction: null,
                arguments: null,
                valid: false,
                rsData: null,
                rtData: null,
                aluOut: null,
                rd: null,
                stall: false
            };
        this.df1Bubble =
            {
                pc: null,
                fetched: null,
                text: null,
                instruction: null,
                arguments: null,
                valid: false,
                rsData: null,
                rtData: null,
                aluOut: null,
                rd: null,
                readData: null
            };
        this.df2Bubble =
            {
                pc: null,
                fetched: null,
                text: null,
                instruction: null,
                arguments: null,
                valid: false,
                rsData: null,
                rtData: null,
                aluOut: null,
                rd: null,
                readData: null
            };
        this.tcBubble =
            {
                pc: null,
                fetched: null,
                text: null,
                instruction: null,
                arguments: null,
                valid: false,
                rsData: null,
                rtData: null,
                aluOut: null,
                rd: null,
                readData: null
            };
        this.cycleCounter = -1;
        this.stackPointer = -1;
    };
    return MIPSCore;
}());
function rangeCheck(value, bits) {
    if (bits == 32) {
        return true; //No other option.
    }
    if (bits > 32) {
        return false; //Impossible.
    }
    var min = -(1 << bits - 1);
    var max = (1 << bits - 1) - 1;
    value = signExt(value, bits);
    if (((value >> 0) <= max) && ((value >> 0) >= min)) {
        return true;
    }
    return false;
}
/*
    signExt

    Sign extends an n-bit value to fit Javascript limits.

    Usage signExt(value, n)
*/
function signExt(value, bits) {
    var mutableValue = value;
    if ((mutableValue & (1 << (bits - 1))) !== 0) {
        mutableValue = ((~(0) >>> bits) << bits) | value;
    }
    return mutableValue;
}
/*
    catBytes
    
    Converts bytes stored in a little endian fashion to a proper js integer.
*/
function catBytes(bytes) {
    if (bytes.length > 4) {
        return null;
    }
    var storage = 0 >>> 0;
    for (var i = 0; i < bytes.length; i++) {
        storage = storage | (bytes[i] << (8 * i));
    }
    return storage;
}
/// <reference path="InstructionSet.ts"/>
/// <reference path="MIPS.ts"/>
// The Zero Interface
// Should be mostly pure Javascript, as it is indeed an interface for Javascript.
// INTERFACE GUIDE: If null, then it looks like it was successful. Else, it is unsuccessful.
var debug = false;
var consoleTests = false;
function h2b(hex) {
    var hexArr = hex.split(' '); // Remove spaces, then seperate characters
    var byteArr = [];
    for (var i = 0; i < hexArr.length; i++) {
        var value = parseInt(hexArr[i], 16);
        if (!isNaN(value)) {
            byteArr.push(value);
        }
    }
    return byteArr;
}
function assemble(core, data) {
    var token = core.instructionSet.tokenize(data);
    if (debug) {
        console.log(token.labels);
        console.log(token.addresses);
    }
    if (token.errorMessage === null) {
        return core.instructionSet.assemble(null, 0, token.lines, token.labels, token.addresses);
    }
    else {
        return { errorMessage: token.errorMessage, machineCode: null, size: 0 };
    }
}
function loadIntoMemory(core, data) {
    if (core.memset(0, data) === null)
        return "Program is too large.";
    return null;
}
function loadMemStep(core, data) {
    var load = loadIntoMemory(core, data);
    if (load !== null) {
        return load;
    }
    simulateStep(core);
}
function passPipeline(core) {
    var cycleParts = [];
    var instName = "";
    /*if (core.stall) {
        if (core.isBubble.valid)
            cycleParts.push("STALL");
        if (core.rfBubble.valid)
            cycleParts.push("STALL");
        if (core.eBubble.valid)
            cycleParts.push("STALL");
    }
    else {*/
    if (core.ifBubble.valid) {
        cycleParts.push("IF");
        if (core.ifBubble.instruction)
            instName = core.ifBubble.instruction.mnemonic;
    }
    if (core.isBubble.valid)
        cycleParts.push("IS");
    if (core.rfBubble.valid)
        cycleParts.push("RF");
    if (core.eBubble.valid)
        cycleParts.push("EX");
    //}
    if (core.df1Bubble.valid)
        cycleParts.push("DF");
    if (core.df2Bubble.valid)
        cycleParts.push("DS");
    if (core.tcBubble.valid)
        cycleParts.push("TC");
    if (core.writeBackValid)
        cycleParts.push("WB");
    core.addCycle(instName, cycleParts);
}
function simulateStep(core) {
    var cycle = core.cycle();
    if (cycle == "SYSCALL") {
        return "@Oak_Ecall";
    }
    if (cycle != null) {
        return cycle;
    }
    core.instructionCallback("End of Cycle " + core.cycleCounter);
    passPipeline(core);
    return null;
}
//It is recommended to simulateStep
function simulate(core, data) {
    var load = loadIntoMemory(core, data);
    if (load !== null) {
        return load;
    }
    return continueSim(core);
}
function continueSim(core) {
    var step = simulateStep(core);
    var i = 0;
    for (var i = 0; i < 16384 && step === null; i++) {
        step = simulateStep(core);
    }
    if (i == 16384) {
        return "ERROR: Possible Infinite Loop";
    }
    if (step !== null) {
        return step;
    }
    return null;
}
function registerRead(core, index) {
    return core.registerFile.read(index);
}
function registerWrite(core, index, value) {
    core.registerFile.write(index, value);
}
function getMemory(core) {
    return core.memory;
}
function getRegisterABINames(core) {
    return core.registerFile.abiNames;
}
function resetCore(core) {
    core.clearPipeline();
    core.reset();
}
Array.prototype.Oak_hex = function () {
    var hexadecimal = "";
    for (var i = 0; i < this.length; i++) {
        var hexRepresentation = this[i].toString(16).toUpperCase();
        if (hexRepresentation.length === 1) {
            hexRepresentation = "0" + hexRepresentation;
        }
        hexadecimal += hexRepresentation + " ";
    }
    return hexadecimal;
};
// //Terminal Test
// var program = 
// `
// addi $s0, $zero, 13
// addi $s1, $zero, 1
// addi $s2, $zero, 2
// addi $s3, $zero, 0
// loop: beq $s1, $s0, exit
// add $s3, $s3, $s2
// j loop
// exit: syscall
// `;
// var done = false;
// var core = new MIPSCore(2048, function() { console.log("RECIEVED KILL COMMAND"); process.exit(0); }, function(data) { console.log(data); }, function(){}, function(){});
// var op = assemble(core, program);
// core.memset(0, op.machineCode);
// while (!done)
// {
//     simulateStep(core);
// } 
